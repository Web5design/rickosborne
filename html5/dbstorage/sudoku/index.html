<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
		<title>Sudoku with the HTML5 Database Storage API</title>
		<style type="text/css">
html, body, h1 {
	margin: 0;
	padding: 0;
}
html {
	background-color: #555;
	position: relative;
}
body {
	background-color: #555;
	color: black;
	font-family: "Lucida Grande", Calibri, Tahoma, Helvetica, Arial, sans-serif;
	margin: 0;
	padding: 16px;
	height: 100%;
	width: 100%;
	border: none;
	position: fixed;
}
#board {
	position: absolute;
	top: 4px;
	left: 4px;
}
#inst {
	position: fixed;
	top: 4px;
	right: 4px;
	background-color: white;
	padding: 0.75em;
	width: 40px;
	border: 1px solid #ccc;
}
		</style>
		<script language="JavaScript" type="text/javascript">
// <![CDATA[
if(typeof RICKO == "undefined" || !RICKO) { var RICKO = {}; }
RICKO.SudokuModelDBStore = function(dbName, dbVersion, dbTitle) {
	var that       = this;
	var db         = null;	
	var DB_VERSION = "1.0";
	var DB_TITLE   = "Sudoku Game by rickosborne.org";
	var DB_BYTES   = 100000;
	var boards     = {
		"Wikipedia": "53  7    6  195    98    6 8   6   34  8 3  17   2   6 6    28    419  5    8  79"
	};
	var sqlFailed = function(tx, e) {
		console.log("Transaction Failed:\n" + e.message);
		alert("Transaction Failed:\n" + e.message);
	}; // sqlFailed
	var logTable = function(db, n) {
		db.transaction(function(tx) {
			tx.executeSql("SELECT * FROM " + n + ";", [], function(tx, r) {
				console.log("Table " + n + " (" + r.rows.length + "):");
				var rows = [];
				for(var i = 0; i < r.rows.length; i++)
					rows.push(r.rows.item(i));
				console.log(rows);
			}, sqlFailed);
		});
	}; // logTable
	var setupDatabase = function(dbName) {
		if(!window.openDatabase) {
			alert("Your browser does not appear to support the openDatabase call from the HTML5 Database Storage API.");
			return null;
		} // if not database
		db = openDatabase(dbName, DB_VERSION, DB_TITLE, DB_BYTES);
		db.transaction(function(tx) {
			tx.executeSql("DROP VIEW IF EXISTS rs_hints;", [], null, sqlFailed);
			var tables = [ "rs_cells", "rs_possible", "rs_board", "rs_boxes", "rs_rows", "rs_cols", "rs_terms" ];
			for(var i = 0; i < tables.length; i++)
				tx.executeSql("DROP TABLE IF EXISTS " + tables[i] + ";", [], null, sqlFailed);
			tx.executeSql("CREATE TABLE rs_terms (term CHAR(1) NOT NULL PRIMARY KEY);", [], null, sqlFailed);
			tx.executeSql("CREATE TABLE rs_rows  (row  INTEGER NOT NULL PRIMARY KEY);", [], null, sqlFailed);
			tx.executeSql("CREATE TABLE rs_cols  (col  INTEGER NOT NULL PRIMARY KEY);", [], null, sqlFailed);
			tx.executeSql("CREATE TABLE rs_boxes (box  INTEGER NOT NULL PRIMARY KEY);", [], null, sqlFailed);
			for(var i = 1; i <= 9; i++) {
				tx.executeSql("INSERT INTO rs_terms (term) VALUES (?);", [ "" + i ], null, sqlFailed);
				tx.executeSql("INSERT INTO rs_rows  (row)  VALUES (?);", [ i ], null, sqlFailed);
				tx.executeSql("INSERT INTO rs_cols  (col)  VALUES (?);", [ i ], null, sqlFailed);
				tx.executeSql("INSERT INTO rs_boxes (box)  VALUES (?);", [ i - 1 ], null, sqlFailed);
			} // for i
			tx.executeSql("CREATE TABLE rs_board (row INTEGER NOT NULL, col INTEGER NOT NULL, box INTEGER NOT NULL, PRIMARY KEY (row, col), FOREIGN KEY (row) REFERENCES rs_rows (row), FOREIGN KEY (col) REFERENCES rs_cols (col), FOREIGN KEY (box) REFERENCES rs_boxes (box));", [], null, sqlFailed);
			tx.executeSql("INSERT INTO rs_board (row, col, box) SELECT row, col, (((row - 1) / 3) * 3) + ((col - 1) / 3) FROM rs_rows, rs_cols", [], null, sqlFailed);
			tx.executeSql("CREATE TABLE rs_possible (row INTEGER NOT NULL, col INTEGER NOT NULL, box INTEGER NOT NULL, term INTEGER NOT NULL, PRIMARY KEY (row, col, term), FOREIGN KEY (row) REFERENCES rs_rows (row), FOREIGN KEY (col) REFERENCES rs_cols (col), FOREIGN KEY (box) REFERENCES rs_boxes (box), FOREIGN KEY (term) REFERENCES rs_terms (term));", [], null, sqlFailed);
			tx.executeSql("INSERT INTO rs_possible (row, col, box, term) SELECT row, col, box, term FROM rs_board, rs_terms;");
			tx.executeSql("CREATE TABLE rs_cells (row INTEGER NOT NULL, col INTEGER NOT NULL, box INTEGER NOT NULL, term INTEGER NOT NULL, PRIMARY KEY (row, col), FOREIGN KEY (row) REFERENCES rs_rows (row), FOREIGN KEY (col) REFERENCES rs_cols (col), FOREIGN KEY (box) REFERENCES rs_boxes (box), FOREIGN KEY (term) REFERENCES rs_terms (term));", [], null, sqlFailed);
			tx.executeSql("CREATE TABLE IF NOT EXISTS rs_saved (row INTEGER NOT NULL, col INTEGER NOT NULL, box INTEGER NOT NULL, term INTEGER NOT NULL, PRIMARY KEY (row, col), FOREIGN KEY (row) REFERENCES rs_rows (row), FOREIGN KEY (col) REFERENCES rs_cols (col), FOREIGN KEY (box) REFERENCES rs_boxes (box), FOREIGN KEY (term) REFERENCES rs_terms (term));", [], null, sqlFailed);
			tx.executeSql("INSERT INTO rs_cells (row, col, box, term) SELECT row, col, box, term FROM rs_saved;", [], null, sqlFailed);
			tx.executeSql("CREATE VIEW rs_hints AS SELECT p.row, p.col, MIN(p.box) AS box, MIN(p.term) AS term FROM rs_possible AS p LEFT JOIN rs_cells AS c ON ((p.row = c.row) AND (p.term = c.term)) OR ((p.col = c.col) AND (p.term = c.term)) OR ((p.box = c.box) AND (p.term = c.term)) OR ((p.row = c.row) AND (p.col = c.col)) WHERE (c.term IS NULL) GROUP BY p.row, p.col HAVING COUNT(*) = 1;", [], null, sqlFailed);
		});
		// logTable(db, "rs_board");
		return db;
	}; // setupDatabase
	var loadBoard = function(boardName, overwrite, doneCallback) {
		var cells = boards[boardName] || boardName || "";
		if(cells.length != 81) {
			console.log("Board '" + boardName + "' seems to be malformed.");
			return false;
		} // if wrong length
		db.transaction(function(tx) {
			tx.executeSql("SELECT COUNT(*) AS cellCount FROM rs_cells;", [], function(tx, r) {
				if(overwrite || (r.rows.length != 1) || (r.rows.item(0).cellCount == 0)) {
					tx.executeSql("DELETE FROM rs_cells;", [], null, sqlFailed);
					var row = 1;
					var col = 0;
					for (var i = 0; i < 81; i++) {
						var term = cells.charAt(i);
						col++;
						if(col > 9) { col = 1; row++; }
						if(term === " ") continue;
						var box = (Math.floor((row - 1) / 3) * 3) + Math.floor((col - 1) / 3);
						tx.executeSql("INSERT INTO rs_cells (row, col, box, term) VALUES (?, ?, ?, ?);", [ row, col, box, term ], null, sqlFailed);
					} // for i
				} // if overwriting
			}, sqlFailed);
		}, sqlFailed, doneCallback);
	}; // loadBoard
	var deleteCell = function(row, col, doneCallback) {
		db.transaction(function(tx) {
			tx.executeSql("DELETE FROM rs_cells WHERE (row = ?) AND (col = ?);", [ row, col ], doneCallback, sqlFailed);
		});
	}; // deleteCell
	var updateCell = function(row, col, box, term, doneCallback, invalidCallback) {
		db.transaction(function(tx) {
			tx.executeSql("SELECT row, col, box, term AS blocks FROM rs_cells WHERE ((row = ?) OR (col = ?) OR (box = ?)) AND (term = ?);", [ row, col, box, term ], function(tx, res) {
				if(res.rows.length == 0) {
					tx.executeSql("DELETE FROM rs_cells WHERE (row = ?) AND (col = ?);", [ row, col ], function(tx) {
						tx.executeSql("INSERT INTO rs_cells (row, col, box, term) VALUES (?, ?, ?, ?);", [ row, col, box, term ], doneCallback, sqlFailed);
					}, sqlFailed);
				} // if one row back
				else if((res.rows.length == 1) && (res.rows.item(0).row == row) && (res.rows.item(0).col == col)) {}
				else {
					var blocks = [];
					for(var i = 0; i < res.rows.length; i++) {
						var rec = res.rows.item(i);
						blocks.push({ row: rec.row - 1, col: rec.col - 1 });
					}
					invalidCallback(blocks);
				}
			}, sqlFailed);
		});
	}; // updateCell
	var cheatAddHints = function(doneCallback) {
		db.transaction(function(tx) {
			tx.executeSql("INSERT INTO rs_cells (row, col, box, term) SELECT row, col, box, term FROM rs_hints;", [], doneCallback, sqlFailed);
		});
	}; // cheatAddHints
	var saveBoard = function(doneCallback) {
		db.transaction(function(tx) {
			tx.executeSql("DELETE FROM rs_saved;", [], function(tx) {
				tx.executeSql("INSERT INTO rs_saved (row, col, box, term) SELECT row, col, box, term FROM rs_cells;", [], null, sqlFailed);
			}, sqlFailed);
		});
		if(doneCallback) doneCallback();
	}; // saveBoard
	var getHints = function(doneCallback) {
		db.transaction(function(tx) {
			tx.executeSql("SELECT row, col, box, term FROM rs_hints;", [], function(tx, r) {
				var hints = [];
				for(var i = 0; i < r.rows.length; i++) {
					var rec = r.rows.item(i);
					hints.push({ row: rec.row - 1, col: rec.col - 1, box: rec.box, term: rec.term });
				} // for i
				doneCallback(hints);
			}, sqlFailed);
		});
	}; // getHints
	var getKnowns = function(doneCallback) {
		db.transaction(function(tx) {
			tx.executeSql("SELECT row, col, box, term FROM rs_cells;", [], function(tx, r) {
				var knowns = [];
				for(var i = 0; i < r.rows.length; i++) {
					var rec = r.rows.item(i);
					knowns.push({ row: rec.row - 1, col: rec.col - 1, box: rec.box, term: rec.term });
				} // for i
				doneCallback(knowns);
			}, sqlFailed);
		}); // transaction
	}; // getKnowns
	setupDatabase(dbName);
	return {
		loadBoard:     loadBoard,
		deleteCell:    deleteCell,
		updateCell:    updateCell,
		cheatAddHints: cheatAddHints,
		saveBoard:     saveBoard,
		getHints:      getHints,
		getKnowns:     getKnowns
	};
}; // SudokuModelDBStore
RICKO.SudokuViewCanvas = function(containerId, parentId, instructionsId) {
	var that = this;
	var getEl = function(n) { return window.document.getElementById(n); };
	var body  = getEl(parentId);
	var inst  = getEl(instructionsId);
	var board = getEl(containerId);
	var ctx   = board.getContext("2d");
	var pad   = 20;
	var backGrad  = null;
	var touchGrad = null;
	var badGrad   = null;
	var showHints = false;
	var empty = { "row": -1, "col": -1, "box": -1  };
	var cell  = empty;
	var badCommand = false;
	var badTimeout = null;
	var showHints  = false;
	var blocks     = [];
	var gridSize   = 0;
	var cellSize   = 0;
	var getHints   = null;
	var getKnowns  = null;
	var toggleHints = function() { showHints = !showHints; };
	var setSelectedCell = function(row, col) {
		buzzDone();
		if((row == -1) || (col == -1))
			cell = empty;
		else
			cell = makeCell(row, col);
		drawBoard();
	}; // setSelectedCell
	var getSelectedCell = function() { return { row: cell.row, col: cell.col, box: cell.box }; };
	var setBlocks = function(blockers) {
		blocks = [];
		for(var i = 0; i < blockers.length; i++)
			blocks.push(makeCell(blockers[i].row, blockers[i].col));
	}; // setBlocks
	var setHintsCallback = function(hintsCallback) { getHints = hintsCallback; };
	var setKnownsCallback = function(knownsCallback) { getKnowns = knownsCallback; };
	var resizeBoard = function() {
		var bh = body.innerHeight || body.clientHeight || body.offsetHeight || body.scrollHeight;
		var bw = body.innerWidth  || body.clientWidth  || body.offsetWidth  || body.scrollWidth;
		var w = Math.floor(((bw > bh) ? bh : bw) - (pad * 2));
		var iw = bw - w - (pad * 3.5);
		if (iw < 200) {
			w -= (200 - iw); 
			iw = 200;
		}
		if (board.width != w) {
			buzzDone();
			inst.style.width = iw + "px";
			board.width = w;
			board.height = w;
			gridSize = (board.width > board.height) ? board.height : board.width;
			cellSize = gridSize / 9.0;
			backGrad = ctx.createLinearGradient(0,0,gridSize,gridSize);
				backGrad.addColorStop(0, "#eeeed0");
				backGrad.addColorStop(1.0, "#ffffff");
			touchGrad = ctx.createLinearGradient(0,0,0,cellSize);
				touchGrad.addColorStop(0, "rgba(63,127,255,0.2)");
				touchGrad.addColorStop(1, "rgba(63,127,255,0.5)");
			badGrad = ctx.createLinearGradient(0,0,0,cellSize);
				badGrad.addColorStop(0, "rgba(255,127,63,0.2)");
				badGrad.addColorStop(1, "rgba(255,127,63,0.5)");
		} // if resized
	}; // resizeBoard
	var drawTerm = function(x, y, s, t, color) {
		x += (s * 0.1);
		y += (s * 0.1);
		s *= 0.8;
		ctx.save();
			if (t == 9) {
				t = 6;
				// ctx.rotate(Math.PI);
				ctx.translate(x + s, y + s);
				ctx.scale(s / -16, s / -16);
			} else {
				ctx.translate(x, y);
				ctx.scale(s / 16, s / 16);
			}
			ctx.strokeStyle = color;
			ctx.lineCap     = "round";
			ctx.lineJoin    = "miter";
			ctx.lineWidth   = 1.15;
			ctx.beginPath();
			switch(t) {
				case 1: ctx.moveTo(6, 3); ctx.lineTo(8, 2); ctx.lineTo(8, 14); break;
				case 2: ctx.moveTo(5, 5); ctx.arc(8, 5, 3, Math.PI, Math.PI / 5, false); ctx.lineTo(5, 14); ctx.lineTo(11, 14);  break;
				case 3: ctx.moveTo(5.25, 5.25); ctx.arc(8, 5, 2.75, Math.PI, Math.PI * 7 / 16, false); ctx.arc(8, 11, 3, Math.PI * -7 / 16, Math.PI, false); break;
				case 4: ctx.moveTo(13, 9); ctx.lineTo(3, 9); ctx.lineTo(9, 2); ctx.lineTo(9, 14); break;
				case 5: ctx.moveTo(12, 2); ctx.lineTo(6, 2); ctx.lineTo(4.5, 6); ctx.arc(8, 9.5, 4.5, Math.PI * -3 / 4, Math.PI * 3 / 4, false); break;
				case 6: ctx.moveTo(10, 2); ctx.lineTo(5.5, 8); ctx.arc(8, 10.5, 3.5, Math.PI * -4 / 5, Math.PI * -2.5 / 5, true); break;
				case 7: ctx.moveTo(5, 2); ctx.lineTo(11, 2); ctx.lineTo(5, 14); ctx.moveTo(7, 7.5); ctx.lineTo(9, 8); break;
				case 8: ctx.arc(8, 4.6, 2.6, Math.PI * 5 / 8, Math.PI * 3 / 8, false); ctx.arc(8, 10, 3.4, Math.PI * 2 / -8, Math.PI * 10 / 8, false); ctx.closePath(); break;
			}; // switch t
			ctx.stroke();
		ctx.restore();
	}; // drawTerm
	var buzzCell = function() {
		badCommand = true;
		drawBoard();
		badTimeout = setTimeout(function() { buzzDone(); drawBoard(); }, 500);
	}; // buzzCell
	var buzzDone = function() {
		badCommand = false;
		blocks = [];
		if(badTimeout) { clearTimeout(badTimeout); badTimeout = null; }
	}; // buzzDone
	var clickBoard = function(event) {
		if(!event) event = window.event;
		var x = event.clientX - board.offsetLeft;
		var y = event.clientY - board.offsetTop;
		var row = Math.floor(y / cellSize);
		var col = Math.floor(x / cellSize);
		var box = (Math.floor(row / 3) * 3) + Math.floor(col / 3);
		if ((col >= 0) && (col <= 8) && (row >= 0) && (row <= 8) && (box >= 0) && (box <= 8) && ((row != cell.row) || (col != cell.col)))
			cell = makeCell(row, col);
		else
			cell = makeCell(-1, -1);
		drawBoard();
		event.cancelBubble = true;
		if(event.stopPropagation) event.stopPropagation();
	}; // clickBoard
	var makeCell = function(row, col) {
		var ell = {
			"row": row,
			"col": col,
			"box": row == -1 ? -1 : (Math.floor(row / 3) * 3) + Math.floor(col / 3),
			"size": cellSize
		};
		if ((row != -1) && (col != -1)) {
			ell.x1 = Math.round(col * cellSize);
			ell.x2 = Math.round(ell.x1 + cellSize);
			ell.y1 = Math.round(row * cellSize);
			ell.y2 = Math.round(ell.y1 + cellSize);
			ell.w = Math.round(cellSize);
			ell.h = Math.round(cellSize);
		}
		return ell;
	}; // makeCell
	var drawBoard = function() {
		resizeBoard();
		ctx.save();
			// background gradient
			ctx.fillStyle = backGrad;
			ctx.fillRect(0,0,gridSize,gridSize);
		ctx.restore();
		if(blocks.length > 0) {
			ctx.save();
				ctx.fillStyle = badGrad;
				for(var i = 0; i < blocks.length; i++) {
					ctx.save();
					ctx.translate(blocks[i].x1, blocks[i].y1);
					ctx.fillRect(0, 0, blocks[i].w, blocks[i].h);	
					ctx.restore();
				} // for i
			ctx.restore();
		} // if blockers
		if (cell.box != -1) {
			// selected cell
			ctx.save();
			ctx.fillStyle = badCommand ? badGrad : touchGrad;
			ctx.translate(cell.x1, cell.y1);
			ctx.fillRect(0, 0, cell.w, cell.h);
			ctx.restore();
		} // if selected cell
		ctx.save();
			// lines
			ctx.strokeStyle = "#000000";
			ctx.lineCap     = "butt";
			ctx.lineJoin    = "miter";
			ctx.save();
				// cell lines
				ctx.linewidth = 2;
				ctx.beginPath();
				for(var i = 1; i < 9; i++) {
					ctx.moveTo(i * cellSize, 0);
					ctx.lineTo(i * cellSize, gridSize);
					ctx.moveTo(0, i * cellSize);
					ctx.lineTo(gridSize, i * cellSize);
				} // for i
				ctx.closePath();
				ctx.stroke();
			ctx.restore();
			ctx.save();
				// box lines
				ctx.lineWidth = 4;
				ctx.beginPath();
				ctx.moveTo(gridSize / 3, 0);
				ctx.lineTo(gridSize / 3, gridSize);
				ctx.moveTo(gridSize * 2 / 3, 0);
				ctx.lineTo(gridSize * 2 / 3, gridSize);
				ctx.moveTo(0, gridSize / 3);
				ctx.lineTo(gridSize, gridSize / 3);
				ctx.moveTo(0, gridSize * 2 / 3, 0);
				ctx.lineTo(gridSize, gridSize * 2 / 3);
				ctx.closePath();
				ctx.stroke();
			ctx.restore();
			ctx.save();
				// heavy border
				ctx.lineWidth = 4;
				ctx.strokeRect(2,2,gridSize-4,gridSize-4);
			ctx.restore();
		ctx.restore();
		if(showHints && getHints)
			getHints(function(hints) {
				for(var i = 0; i < hints.length; i++) {
					var c = makeCell(hints[i].row, hints[i].col);
					drawTerm(c.x1, c.y1, c.w, hints[i].term, "#cccccc");
				} // for i
			});
		if(getKnowns)
			getKnowns(function(knowns) {
				for(var i = 0; i < knowns.length; i++) {
					var c = makeCell(knowns[i].row, knowns[i].col);
					drawTerm(c.x1, c.y1, c.w, knowns[i].term, knowns.length == 81 ? "#33ff33" : "#000000");
				} // for i
			});
	}; // drawBoard
	return {
		resizeBoard:       resizeBoard,
		drawBoard:         drawBoard,
		toggleHints:       toggleHints,
		setSelectedCell:   setSelectedCell,
		getSelectedCell:   getSelectedCell,
		clickBoard:        clickBoard,
		setHintsCallback:  setHintsCallback,
		setKnownsCallback: setKnownsCallback,
		setBlocks:         setBlocks,
		buzzCell:          buzzCell
	};
}; // SudokuViewCanvas
RICKO.SudokuBoard = function(modelObj, viewObj) {
	var that = this;
	var model = modelObj;
	var view  = viewObj;
	view.setHintsCallback(model.getHints);
	view.setKnownsCallback(model.getKnowns);
	view.resizeBoard();
	view.drawBoard();
	var loadBoard = function(boardName, overwrite) {
		model.loadBoard(boardName, overwrite, view.drawBoard);
	}; // loadBoard
	var keyBoard = function(event) {
		if(!event) event = window.event;
		var key = (event.keyCode || event.charCode);
		if(key == 72) {
			view.toggleHints();
			view.drawBoard();
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;
		} // hints
		if(key == 67) {
			model.cheatAddHints(view.drawBoard);
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;
		} // cheat
		if(key == 82) {
			loadBoard('Wikipedia', true);
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;
		} // reset
		if(key == 83) {
			model.saveBoard();
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;			
		} // save
		if((key >= 33) && (key <= 36)) {
			if(key == 33)      view.setSelectedCell(0,8);
			else if(key == 34) view.setSelectedCell(8,0);
			else if(key == 35) view.setSelectedCell(8,8);
			else if(key == 36) view.setSelectedCell(0,0);
			view.drawBoard();
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;
		} // home, end, etc
		var cell = view.getSelectedCell();
		if((cell.row == -1) || (cell.box == -1) || (cell.col == -1)) return;
		// console.log(key);
		if((key == 8) || (key == 48) || (key == 96) || (key == 46)) {
			model.deleteCell(cell.row + 1, cell.col + 1, view.drawBoard);
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;
		} // delete/clear/zero
		if((key >= 37) && (key <= 40)) {
			var newCell = null;
			if((key == 37) && (cell.col > 0))      newCell = [ cell.row, cell.col - 1 ];
			else if((key == 38) && (cell.row > 0)) newCell = [ cell.row - 1, cell.col ];
			else if((key == 39) && (cell.col < 8)) newCell = [ cell.row, cell.col + 1 ];
			else if((key == 40) && (cell.row < 8)) newCell = [ cell.row + 1, cell.col ];
			if(newCell != null)
				view.setSelectedCell(newCell[0], newCell[1]);
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;
		}
		if(((key >= 49) && (key <= 57)) || ((key >= 97) && (key <= 105))) {
			model.updateCell(cell.row + 1, cell.col + 1, cell.box, key - (key > 95 ? 96 : 48), view.drawBoard, function(blockers) {
				view.setBlocks(blockers);
				view.buzzCell();
			});
			event.cancelBubble = true;
			if(event.stopPropagation) event.stopPropagation();
			return;
		} // digit
	}; // keyBoard
	board.addEventListener("change", view.drawBoard, true);
	board.addEventListener("click", view.clickBoard, true);
	body.addEventListener("resize", view.drawBoard, true);
	window.addEventListener("resize", view.drawBoard, true);
	window.addEventListener("keydown", keyBoard, true);
	return {
		loadBoard: loadBoard
	};
} // SudokuBoard
// ]]>
		</script>
	</head>
	<body onload="sudokuBoard = new RICKO.SudokuBoard(new RICKO.SudokuModelDBStore('ricko-sudoku'), new RICKO.SudokuViewCanvas('board','body','inst'));sudokuBoard.loadBoard('Wikipedia', false);" id="body" onresize="sudokuBoard.drawBoard();" onresizeend="sudokuBoard.drawBoard();">
		<canvas id="board">
			<p>It looks like your browser doesn't support the <kbd>canvas</kbd> element.  Sorry!</p>
		</canvas>
		<div id="inst">
			<h1>Sudoku + HTML5</h1>
			<p>Standard <a href="http://en.wikipedia.org/wiki/Sudoku">Sudoku rules</a> apply.</p>
			<p>Click on a cell to select it, then press a digit to write it down.</p>
			<ul>
				<li><strong>Arrows, Home, End, PgUp, PgDn</strong>: Navigate</li>
				<li><strong>Delete, Bksp, 0</strong>: Erase</li>
				<li><strong>H</strong>: Hints</li>
				<li><strong>C</strong>: Cheat</li>
				<li><strong>R</strong>: Reset</li>
				<li><strong>S</strong>: Save</li>
			</ul>
			<p>This implementation is Copyright 2010 by <a href="http://rickosborne.org/">Rick Osborne</a>, all rights reserved.</p>
		</div>
	</body>
</html>
